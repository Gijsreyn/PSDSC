function ReadDscPsAdapterSchema
{
    <#
    .SYNOPSIS
        Read the Desired State Configuration PowerShell adapter cache.

    .DESCRIPTION
        The function ReadDscPsAdapterSchema reads the PowerShell adapter cache both for Windows PowerShell and PowerShell.
        It builds upon the work of Andrew Menagarishvili, one of the core members on the DSC project, and reads the required files generated by 'powershell.resource.ps1'.

    .PARAMETER ReturnTypeInfo
        Switch parameter to only return the type name(s).

    .EXAMPLE
        PS C:\> ReadDscAdapterSchema

        Returns:
        Type                                       Description           Version  ResourceInput
        ----                                       -----------           -------  -------------

    .NOTES
        For more details, go to module repository at: https://github.com/Gijsreyn/PSDSC.
    #>
    [CmdletBinding()]
    [OutputType([System.Array])]
    param
    (
        [System.Management.Automation.SwitchParameter]
        $ReturnTypeInfo
    )

    begin
    {
        function _generateCodeExample ($properties)
        {
            $resourceInput = [System.Collections.Generic.List[System.Array]]::new()
            $inputObject = @{}
            $mandatory = @{}
            $properties | ForEach-Object {
                $typeName = $_.PropertyType.Split(".")[-1].TrimEnd("]").Replace("[", "")
                $inputObject.Add($_.Name, "<$typeName>")

                if ($_.IsMandatory -eq $true)
                {
                    $mandatory.Add($_.Name, "<$typeName>")
                }
            }
            $resourceInput.Add(($mandatory | ConvertTo-Json -Depth 10 -Compress))
            $resourceInput.Add(($inputObject | ConvertTo-Json -Depth 10 -Compress))

            return $resourceInput
        }

        Write-Verbose -Message ("Starting: {0}" -f $MyInvocation.MyCommand.Name)
    }

    process
    {
        $cacheFilePath = if ($IsWindows)
        {
            # PS 6+ on Windows
            Join-Path -Path $env:LocalAppData "dsc\PSAdapterCache.json"
        }
        else
        {
            # either WinPS or PS 6+ on Linux/Mac
            if ($PSVersionTable.PSVersion.Major -le 5)
            {
                Join-Path -Path $env:LocalAppData "dsc\WindowsPSAdapterCache.json"
            }
            else
            {
                Join-Path -Path $env:HOME ".dsc" "PSAdapterCache.json"
            }

        }

        if (-not (Test-Path $cacheFilePath))
        {
            return
        }

        Write-Verbose -Message ("Retrieving cache content from: '{0}'" -f $cacheFilePath)

        $cacheContent = Get-Content $cacheFilePath | ConvertFrom-Json

        $objectBag = foreach ($resource in $cacheContent.ResourceCache)
        {
            # create manifest object
            $resourceObject = [PSCustomObject]@{
                Type          = $resource.type
                Description   = $resource.DscResourceInfo.FriendlyName
                Version       = $resource.DscResourceInfo.Version
                ResourceInput = $null
            }

            # add the example code
            $exampleCode = @((_generateCodeExample -properties $resource.DscResourceInfo.Properties))
            $resourceObject.resourceInput = $exampleCode

            $resourceObject
        }
    }
    end
    {
        Write-Verbose -Message ("Ended: {0}" -f $MyInvocation.MyCommand.Name)
        if ($ReturnTypeInfo)
        {
            return ($objectBag.Type)
        }
        return $objectBag
    }
}
